# Amendment: State → Execution Type Separation

## Problem

The original specs defined `Execution` struct with typed fields (`status`, `halt_data`, `recover_to`) but Engine/Storage used untyped `ctx[:_status]`, `ctx[:_halt]`, `ctx[:_resume_step]` instead. This created:

1. Type safety issues (symbols become strings after JSON round-trip)
2. Polluted `ctx` with internal state
3. Dead code (`Execution`, `ErrorResult` structs never used)

## Solution

- `State` = runtime (passed between executors, clean `ctx` with user variables only)
- `Execution` = persistence (typed `status`, `halt_data`, `error`, `recover_to`, `result`)
- Engine works with `State`, saves `Execution`
- Storage saves/loads `Execution`

---

## TODO

### Phase 1 - Core Types

- [x] **02-TYPES: Update State struct**

  - Remove `from_h` method (not needed for runtime-only struct)
  - Add comment: "ctx contains user workflow variables only"

- [x] **02-TYPES: Update Execution struct**

  - Add `ExecutionStatus` enum: `:pending`, `:running`, `:completed`, `:halted`, `:failed`
  - Add `result` field (Any, optional) - final output when completed
  - Add `error` field (String, optional) - error message when failed
  - Add `to_state` method - converts to State for executor use
  - Add `from_state(state, result)` class method - builds from State + ExecutionResult
  - Add `from_h(hash)` class method - deserialize from storage

- [x] **02-TYPES: Remove ErrorResult**

  - Delete `ErrorResult` struct (errors captured in `Execution.error`)

- [x] **02-TYPES: Update ExecutionResult**
  - Use `ExecutionStatus` enum for status attribute

### Phase 1 - Engine

- [x] **03-EXECUTION: Engine saves Execution**

  - Add `save_execution(state, result)` private method
  - Calls `Execution.from_state(state, result)` then `@store.save(execution)`

- [x] **03-EXECUTION: Engine.run uses save_execution**

  - Initial save: `save_execution(state, ExecutionResult.new(status: :running, ...))`
  - After each step: `save_execution(state, ExecutionResult.new(status: :running, ...))`
  - On completion: `save_execution(state, result)` then return result
  - On timeout: `save_execution(state, result)` with `:failed` status

- [x] **03-EXECUTION: Engine.resume loads Execution**

  - `execution = @store.load(execution_id)`
  - `state = execution.to_state`
  - Resume step from `execution.recover_to || execution.current_step`

- [x] **03-EXECUTION: handle_halt saves Execution**

  - Build `ExecutionResult` with `:halted` status and halt data
  - Call `save_execution(state, result)`

- [x] **03-EXECUTION: Remove ctx[:_*] usage**
  - No `ctx[:_status]`, `ctx[:_halt]`, `ctx[:_resume_step]`, `ctx[:_error]`
  - Keep `ctx[:_last_error]` only for transient error handler access

### Phase 2 - Storage

- [x] **01-STORAGE: Update Store interface**

  - `save(execution)` - receives Execution struct
  - `load(execution_id)` - returns Execution struct

- [x] **01-STORAGE: Update Redis adapter**

  - `serialize_execution` / `deserialize_execution`
  - `find` uses `execution.status` (not `ctx[:_status]`)

- [x] **01-STORAGE: Update ActiveRecord adapter**

  - Save all Execution fields: `status`, `result`, `recover_to`, `halt_data`, `error`
  - Load returns `Core::Execution.new(...)`

- [x] **01-STORAGE: Update Sequel adapter**

  - Same as ActiveRecord

- [x] **01-STORAGE: Update migrations**
  - Add columns: `result` (jsonb), `recover_to` (string), `halt_data` (jsonb), `error` (text)

### Phase 2 - Runners

- [x] **02-RUNNERS: Fix Event struct**

  - Change from `Struct.new(...)` to `class Event < BaseStruct`

- [x] **02-RUNNERS: Update Async runner**

  - `run`: Create `Execution.new(status: :pending, ...)` not `State.new(ctx: {_status: :pending})`
  - `wait`: Use `execution.status` not `state.ctx[:_status]`
  - `status`: Use `execution.status` not `state.ctx[:_status]`
  - `build_result`: Use `execution.result`, `execution.halt_data`, `execution.error`

- [x] **02-RUNNERS: Update Inline adapter**

  - Remove manual status update (Engine handles it)

- [x] **02-RUNNERS: Update Sidekiq adapter**
  - Remove manual status update (Engine handles it)

---

## Verification

After implementation, ensure:

1. ✅ `ctx` only contains user workflow variables
2. ✅ `find(status: :halted)` works without JSON parsing
3. ✅ `execution.to_state` / `Execution.from_state` round-trip correctly
4. ✅ All tests pass with typed Execution fields

---

## ✅ AMENDMENT COMPLETE

**Test Results:** 321 runs, 609 assertions, 0 failures, 0 errors, 0 skips
